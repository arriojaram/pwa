import { __awaiter, __decorate, __param } from "tslib";
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { BehaviorSubject, fromEvent, interval, Subscription } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { switchMap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
/**
 * InjectionToken for specifing ConnectionService options.
 */
export const ConnectionServiceOptionsToken = new InjectionToken('ConnectionServiceOptionsToken');
export const DEFAULT_CONNECTION_STATE = {
    hasInternetAccess: true,
    hasNetworkConnection: window.navigator.onLine
};
export const DEFAULT_HEART_BEAT_INTERVAL = 1000;
// export const DEFAULT_HEART_BEAT_URL = 'https://jsonplaceholder.typicode.com';
export const DEFAULT_HEART_BEAT_URL = 'http://localhost:3000';
export const DEFAULT_HEART_BEAT_RETRY_INTERVAL = 1000;
export var HTTP_REQUEST_METHODS;
(function (HTTP_REQUEST_METHODS) {
    HTTP_REQUEST_METHODS["HEAD"] = "head";
    HTTP_REQUEST_METHODS["GET"] = "get";
    HTTP_REQUEST_METHODS["POST"] = "post";
    HTTP_REQUEST_METHODS["PUT"] = "put";
    HTTP_REQUEST_METHODS["OPTIONS"] = "options";
})(HTTP_REQUEST_METHODS || (HTTP_REQUEST_METHODS = {}));
export const DEFAULT_OPTIONS = {
    enableHeartbeat: false,
    heartbeatUrl: DEFAULT_HEART_BEAT_URL,
    heartbeatInterval: DEFAULT_HEART_BEAT_INTERVAL,
    heartbeatRetryInterval: 1000,
    requestMethod: HTTP_REQUEST_METHODS.HEAD
};
let ConnectionService = class ConnectionService {
    constructor(http, options) {
        this.http = http;
        this.currentState = DEFAULT_CONNECTION_STATE;
        this.serviceOptions = DEFAULT_OPTIONS;
        this.subscription = new Subscription();
        this.httpSubscription = new Subscription();
        this.stateChanged$ = new BehaviorSubject(DEFAULT_CONNECTION_STATE);
        // TODO: Token useValue in providers not working.
        this.serviceOptions = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
        this.checkNetworkState();
        if (this.serviceOptions.enableHeartbeat) {
            this.checkInternetState();
        }
    }
    checkNetworkState() {
        this.subscription.add(fromEvent(window, 'online').subscribe(() => {
            this.currentState.hasNetworkConnection = true;
            this.checkInternetState();
            this.publishState();
        }));
        this.subscription.add(fromEvent(window, 'offline').subscribe(() => {
            this.currentState.hasNetworkConnection = false;
            this.checkInternetState();
            this.publishState();
        }));
    }
    checkInternetState() {
        if (this.serviceOptions.enableHeartbeat) {
            this.subscription = interval(3000).pipe(switchMap(() => __awaiter(this, void 0, void 0, function* () {
                return this.http[this.serviceOptions.requestMethod || HTTP_REQUEST_METHODS.HEAD](this.serviceOptions.heartbeatUrl || DEFAULT_HEART_BEAT_URL, { responseType: 'text' }).subscribe({
                    next: (data) => {
                        this.currentState.hasInternetAccess = true;
                        this.publishState();
                    },
                    error: (err) => {
                        this.currentState.hasInternetAccess = false;
                        this.publishState();
                        throw err;
                    },
                });
            }))).subscribe(res => {
            });
            // this.httpSubscription = timer(0, this.serviceOptions.heartbeatInterval || DEFAULT_HEART_BEAT_INTERVAL)
            //   .pipe(
            //     switchMap(async () => this.http[this.serviceOptions.requestMethod || HTTP_REQUEST_METHODS.HEAD](this.serviceOptions.heartbeatUrl || DEFAULT_HEART_BEAT_URL,
            //       { responseType: 'text' })),
            //     retryWhen(errors =>
            //       errors.pipe(
            //         // log error message
            //         tap(val => {
            //           this.currentState.hasInternetAccess = false;
            //           this.publishState();
            //           throw errors;
            //         }),
            //         // restart after 5 seconds
            //         delay(this.serviceOptions.heartbeatRetryInterval || DEFAULT_HEART_BEAT_RETRY_INTERVAL)
            //       )
            //     )
            //   )
            //   .subscribe(result => {
            //     this.currentState.hasInternetAccess = true;
            //     this.publishState();
            //   });
        }
        else {
            this.currentState.hasInternetAccess = false;
            this.publishState();
        }
    }
    publishState() {
        this.stateChanged$.next(this.currentState);
    }
    /**
   * Monitor Network & Internet connection status by subscribing to this observer. If you set "reportCurrentState" to "false" then
   * function will not report current status of the connections when initially subscribed.
   * @param reportCurrentState Report current state when initial subscription. Default is "true"
   */
    monitor(options) {
        if (options) {
            this.serviceOptions = Object.assign(Object.assign({}, this.serviceOptions), options);
        }
        if (this.serviceOptions.enableHeartbeat) {
            this.checkInternetState();
        }
        return this.stateChanged$;
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
};
ConnectionService.ctorParameters = () => [
    { type: HttpClient },
    { type: undefined, decorators: [{ type: Inject, args: [ConnectionServiceOptionsToken,] }, { type: Optional }] }
];
ConnectionService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ConnectionService_Factory() { return new ConnectionService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(ConnectionServiceOptionsToken, 8)); }, token: ConnectionService, providedIn: "root" });
ConnectionService = __decorate([
    Injectable({
        providedIn: 'root'
    }),
    __param(1, Inject(ConnectionServiceOptionsToken)), __param(1, Optional())
], ConnectionService);
export { ConnectionService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctY29ubmVjdGlvbi1zZXJ2aWNlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1jb25uZWN0aW9uLXNlcnZpY2UvIiwic291cmNlcyI6WyJsaWIvbmctY29ubmVjdGlvbi1zZXJ2aWNlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBYSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEYsT0FBTyxFQUFFLGVBQWUsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFjLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDbEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUEyQzNDOztHQUVHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sNkJBQTZCLEdBQTZDLElBQUksY0FBYyxDQUFDLCtCQUErQixDQUFDLENBQUM7QUFFM0ksTUFBTSxDQUFDLE1BQU0sd0JBQXdCLEdBQW9CO0lBQ3ZELGlCQUFpQixFQUFFLElBQUk7SUFDdkIsb0JBQW9CLEVBQUUsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNO0NBQzlDLENBQUE7QUFFRCxNQUFNLENBQUMsTUFBTSwyQkFBMkIsR0FBRyxJQUFJLENBQUM7QUFDaEQsZ0ZBQWdGO0FBQ2hGLE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFHLHVCQUF1QixDQUFDO0FBQzlELE1BQU0sQ0FBQyxNQUFNLGlDQUFpQyxHQUFHLElBQUksQ0FBQztBQUV0RCxNQUFNLENBQU4sSUFBWSxvQkFNWDtBQU5ELFdBQVksb0JBQW9CO0lBQzlCLHFDQUFhLENBQUE7SUFDYixtQ0FBVyxDQUFBO0lBQ1gscUNBQWEsQ0FBQTtJQUNiLG1DQUFXLENBQUE7SUFDWCwyQ0FBbUIsQ0FBQTtBQUNyQixDQUFDLEVBTlcsb0JBQW9CLEtBQXBCLG9CQUFvQixRQU0v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QUUsQ0FBQTtHQVY3RSxpQkFBaUIsQ0E0RzdCO1NBNUdZLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgZnJvbUV2ZW50LCBpbnRlcnZhbCwgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuLyoqXG4gKiBJbnN0YW5jZSBvZiB0aGlzIGludGVyZmFjZSBpcyB1c2VkIHRvIHJlcG9ydCBjdXJyZW50IGNvbm5lY3Rpb24gc3RhdHVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbm5lY3Rpb25TdGF0ZSB7XG4gIC8qKlxuICAgKiBcIlRydWVcIiBpZiBicm93c2VyIGhhcyBuZXR3b3JrIGNvbm5lY3Rpb24uIERldGVybWluZWQgYnkgV2luZG93IG9iamVjdHMgXCJvbmxpbmVcIiAvIFwib2ZmbGluZVwiIGV2ZW50cy5cbiAgICovXG4gIGhhc05ldHdvcmtDb25uZWN0aW9uOiBib29sZWFuO1xuICAvKipcbiAgICogXCJUcnVlXCIgaWYgYnJvd3NlciBoYXMgSW50ZXJuZXQgYWNjZXNzLiBEZXRlcm1pbmVkIGJ5IGhlYXJ0YmVhdCBzeXN0ZW0gd2hpY2ggcGVyaW9kaWNhbGx5IG1ha2VzIHJlcXVlc3QgdG8gaGVhcnRiZWF0IFVybC5cbiAgICovXG4gIGhhc0ludGVybmV0QWNjZXNzOiBib29sZWFuO1xufVxuXG4vKipcbiAqIEluc3RhbmNlIG9mIHRoaXMgaW50ZXJmYWNlIGNvdWxkIGJlIHVzZWQgdG8gY29uZmlndXJlIFwiQ29ubmVjdGlvblNlcnZpY2VcIi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0aW9uU2VydmljZU9wdGlvbnMge1xuICAvKipcbiAgICogQ29udHJvbHMgdGhlIEludGVybmV0IGNvbm5lY3Rpdml0eSBoZWFydGJlYXQgc3lzdGVtLiBEZWZhdWx0IHZhbHVlIGlzICd0cnVlJy5cbiAgICovXG4gIGVuYWJsZUhlYXJ0YmVhdD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBVcmwgdXNlZCBmb3IgY2hlY2tpbmcgSW50ZXJuZXQgY29ubmVjdGl2aXR5LCBoZWFydGJlYXQgc3lzdGVtIHBlcmlvZGljYWxseSBtYWtlcyBcIkhFQURcIiByZXF1ZXN0cyB0byB0aGlzIFVSTCB0byBkZXRlcm1pbmUgSW50ZXJuZXRcbiAgICogY29ubmVjdGlvbiBzdGF0dXMuIERlZmF1bHQgdmFsdWUgaXMgXCIvL2ludGVybmV0aGVhbHRodGVzdC5vcmdcIi5cbiAgICovXG4gIGhlYXJ0YmVhdFVybD86IHN0cmluZztcbiAgLyoqXG4gICAqIEludGVydmFsIHVzZWQgdG8gY2hlY2sgSW50ZXJuZXQgY29ubmVjdGl2aXR5IHNwZWNpZmllZCBpbiBtaWxsaXNlY29uZHMuIERlZmF1bHQgdmFsdWUgaXMgXCIzMDAwMFwiLlxuICAgKi9cbiAgaGVhcnRiZWF0SW50ZXJ2YWw/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBJbnRlcnZhbCB1c2VkIHRvIHJldHJ5IEludGVybmV0IGNvbm5lY3Rpdml0eSBjaGVja3Mgd2hlbiBhbiBlcnJvciBpcyBkZXRlY3RlZCAod2hlbiBubyBJbnRlcm5ldCBjb25uZWN0aW9uKS4gRGVmYXVsdCB2YWx1ZSBpcyBcIjEwMDBcIi5cbiAgICovXG4gIGhlYXJ0YmVhdFJldHJ5SW50ZXJ2YWw/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBIVFRQIG1ldGhvZCB1c2VkIGZvciByZXF1ZXN0aW5nIGhlYXJ0YmVhdCBVcmwuIERlZmF1bHQgaXMgJ2hlYWQnLlxuICAgKi9cbiAgcmVxdWVzdE1ldGhvZD86ICdnZXQnIHwgJ3Bvc3QnIHwgJ2hlYWQnIHwgJ29wdGlvbnMnO1xuXG59XG5cbi8qKlxuICogSW5qZWN0aW9uVG9rZW4gZm9yIHNwZWNpZmluZyBDb25uZWN0aW9uU2VydmljZSBvcHRpb25zLlxuICovXG5leHBvcnQgY29uc3QgQ29ubmVjdGlvblNlcnZpY2VPcHRpb25zVG9rZW46IEluamVjdGlvblRva2VuPENvbm5lY3Rpb25TZXJ2aWNlT3B0aW9ucz4gPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0Nvbm5lY3Rpb25TZXJ2aWNlT3B0aW9uc1Rva2VuJyk7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0NPTk5FQ1RJT05fU1RBVEU6IENvbm5lY3Rpb25TdGF0ZSA9IHtcbiAgaGFzSW50ZXJuZXRBY2Nlc3M6IHRydWUsXG4gIGhhc05ldHdvcmtDb25uZWN0aW9uOiB3aW5kb3cubmF2aWdhdG9yLm9uTGluZVxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFSVF9CRUFUX0lOVEVSVkFMID0gMTAwMDtcbi8vIGV4cG9ydCBjb25zdCBERUZBVUxUX0hFQVJUX0JFQVRfVVJMID0gJ2h0dHBzOi8vanNvbnBsYWNlaG9sZGVyLnR5cGljb2RlLmNvbSc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFSVF9CRUFUX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBUlRfQkVBVF9SRVRSWV9JTlRFUlZBTCA9IDEwMDA7XG5cbmV4cG9ydCBlbnVtIEhUVFBfUkVRVUVTVF9NRVRIT0RTIHtcbiAgSEVBRCA9ICdoZWFkJyxcbiAgR0VUID0gJ2dldCcsXG4gIFBPU1QgPSAncG9zdCcsXG4gIFBVVCA9ICdwdXQnLFxuICBPUFRJT05TID0gJ29wdGlvbnMnXG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX09QVElPTlM6IENvbm5lY3Rpb25TZXJ2aWNlT3B0aW9ucyA9IHtcbiAgZW5hYmxlSGVhcnRiZWF0OiBmYWxzZSxcbiAgaGVhcnRiZWF0VXJsOiBERUZBVUxUX0hFQVJUX0JFQVRfVVJMLFxuICBoZWFydGJlYXRJbnRlcnZhbDogREVGQVVMVF9IRUFSVF9CRUFUX0lOVEVSVkFMLFxuICBoZWFydGJlYXRSZXRyeUludGVydmFsOiAxMDAwLFxuICByZXF1ZXN0TWV0aG9kOiBIVFRQX1JFUVVFU1RfTUVUSE9EUy5IRUFEXG59O1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBDb25uZWN0aW9uU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgcHJpdmF0ZSBjdXJyZW50U3RhdGU6IENvbm5lY3Rpb25TdGF0ZSA9IERFRkFVTFRfQ09OTkVDVElPTl9TVEFURTtcbiAgcHJpdmF0ZSBzZXJ2aWNlT3B0aW9uczogQ29ubmVjdGlvblNlcnZpY2VPcHRpb25zID0gREVGQVVMVF9PUFRJT05TO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gIHByaXZhdGUgaHR0cFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gIHByaXZhdGUgc3RhdGVDaGFuZ2VkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Q29ubmVjdGlvblN0YXRlPihERUZBVUxUX0NPTk5FQ1RJT05fU1RBVEUpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cDogSHR0cENsaWVudCwgQEluamVjdChDb25uZWN0aW9uU2VydmljZU9wdGlvbnNUb2tlbikgQE9wdGlvbmFsKCkgb3B0aW9uczogQ29ubmVjdGlvblNlcnZpY2VPcHRpb25zKSB7XG4gICAgLy8gVE9ETzogVG9rZW4gdXNlVmFsdWUgaW4gcHJvdmlkZXJzIG5vdCB3b3JraW5nLlxuICAgIHRoaXMuc2VydmljZU9wdGlvbnMgPSB7IC4uLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9O1xuICAgIHRoaXMuY2hlY2tOZXR3b3JrU3RhdGUoKTtcblxuICAgIGlmICh0aGlzLnNlcnZpY2VPcHRpb25zLmVuYWJsZUhlYXJ0YmVhdCkge1xuICAgICAgdGhpcy5jaGVja0ludGVybmV0U3RhdGUoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrTmV0d29ya1N0YXRlKCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChmcm9tRXZlbnQod2luZG93LCAnb25saW5lJykuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFN0YXRlLmhhc05ldHdvcmtDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tJbnRlcm5ldFN0YXRlKCk7XG4gICAgICB0aGlzLnB1Ymxpc2hTdGF0ZSgpO1xuICAgIH0pKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9uLmFkZChmcm9tRXZlbnQod2luZG93LCAnb2ZmbGluZScpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGF0ZS5oYXNOZXR3b3JrQ29ubmVjdGlvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5jaGVja0ludGVybmV0U3RhdGUoKTtcbiAgICAgIHRoaXMucHVibGlzaFN0YXRlKCk7XG4gICAgfSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0ludGVybmV0U3RhdGUoKSB7XG5cbiAgICBpZiAodGhpcy5zZXJ2aWNlT3B0aW9ucy5lbmFibGVIZWFydGJlYXQpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gaW50ZXJ2YWwoMzAwMCkucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKGFzeW5jICgpID0+XG4gICAgICAgICAgdGhpcy5odHRwW3RoaXMuc2VydmljZU9wdGlvbnMucmVxdWVzdE1ldGhvZCB8fCBIVFRQX1JFUVVFU1RfTUVUSE9EUy5IRUFEXSh0aGlzLnNlcnZpY2VPcHRpb25zLmhlYXJ0YmVhdFVybCB8fCBERUZBVUxUX0hFQVJUX0JFQVRfVVJMLFxuICAgICAgICAgICAgeyByZXNwb25zZVR5cGU6ICd0ZXh0JyB9KS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuZXh0OiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuaGFzSW50ZXJuZXRBY2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoU3RhdGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZXJyb3I6IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlLmhhc0ludGVybmV0QWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKS5zdWJzY3JpYmUoXG4gICAgICAgIHJlcyA9PiB7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICAvLyB0aGlzLmh0dHBTdWJzY3JpcHRpb24gPSB0aW1lcigwLCB0aGlzLnNlcnZpY2VPcHRpb25zLmhlYXJ0YmVhdEludGVydmFsIHx8IERFRkFVTFRfSEVBUlRfQkVBVF9JTlRFUlZBTClcbiAgICAgIC8vICAgLnBpcGUoXG4gICAgICAvLyAgICAgc3dpdGNoTWFwKGFzeW5jICgpID0+IHRoaXMuaHR0cFt0aGlzLnNlcnZpY2VPcHRpb25zLnJlcXVlc3RNZXRob2QgfHwgSFRUUF9SRVFVRVNUX01FVEhPRFMuSEVBRF0odGhpcy5zZXJ2aWNlT3B0aW9ucy5oZWFydGJlYXRVcmwgfHwgREVGQVVMVF9IRUFSVF9CRUFUX1VSTCxcbiAgICAgIC8vICAgICAgIHsgcmVzcG9uc2VUeXBlOiAndGV4dCcgfSkpLFxuICAgICAgLy8gICAgIHJldHJ5V2hlbihlcnJvcnMgPT5cbiAgICAgIC8vICAgICAgIGVycm9ycy5waXBlKFxuICAgICAgLy8gICAgICAgICAvLyBsb2cgZXJyb3IgbWVzc2FnZVxuICAgICAgLy8gICAgICAgICB0YXAodmFsID0+IHtcbiAgICAgIC8vICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS5oYXNJbnRlcm5ldEFjY2VzcyA9IGZhbHNlO1xuICAgICAgLy8gICAgICAgICAgIHRoaXMucHVibGlzaFN0YXRlKCk7XG4gICAgICAvLyAgICAgICAgICAgdGhyb3cgZXJyb3JzO1xuICAgICAgLy8gICAgICAgICB9KSxcbiAgICAgIC8vICAgICAgICAgLy8gcmVzdGFydCBhZnRlciA1IHNlY29uZHNcbiAgICAgIC8vICAgICAgICAgZGVsYXkodGhpcy5zZXJ2aWNlT3B0aW9ucy5oZWFydGJlYXRSZXRyeUludGVydmFsIHx8IERFRkFVTFRfSEVBUlRfQkVBVF9SRVRSWV9JTlRFUlZBTClcbiAgICAgIC8vICAgICAgIClcbiAgICAgIC8vICAgICApXG4gICAgICAvLyAgIClcbiAgICAgIC8vICAgLnN1YnNjcmliZShyZXN1bHQgPT4ge1xuICAgICAgLy8gICAgIHRoaXMuY3VycmVudFN0YXRlLmhhc0ludGVybmV0QWNjZXNzID0gdHJ1ZTtcbiAgICAgIC8vICAgICB0aGlzLnB1Ymxpc2hTdGF0ZSgpO1xuICAgICAgLy8gICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50U3RhdGUuaGFzSW50ZXJuZXRBY2Nlc3MgPSBmYWxzZTtcbiAgICAgIHRoaXMucHVibGlzaFN0YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwdWJsaXNoU3RhdGUoKSB7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZWQkLm5leHQodGhpcy5jdXJyZW50U3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gKiBNb25pdG9yIE5ldHdvcmsgJiBJbnRlcm5ldCBjb25uZWN0aW9uIHN0YXR1cyBieSBzdWJzY3JpYmluZyB0byB0aGlzIG9ic2VydmVyLiBJZiB5b3Ugc2V0IFwicmVwb3J0Q3VycmVudFN0YXRlXCIgdG8gXCJmYWxzZVwiIHRoZW5cbiAqIGZ1bmN0aW9uIHdpbGwgbm90IHJlcG9ydCBjdXJyZW50IHN0YXR1cyBvZiB0aGUgY29ubmVjdGlvbnMgd2hlbiBpbml0aWFsbHkgc3Vic2NyaWJlZC5cbiAqIEBwYXJhbSByZXBvcnRDdXJyZW50U3RhdGUgUmVwb3J0IGN1cnJlbnQgc3RhdGUgd2hlbiBpbml0aWFsIHN1YnNjcmlwdGlvbi4gRGVmYXVsdCBpcyBcInRydWVcIlxuICovXG4gIHB1YmxpYyBtb25pdG9yKG9wdGlvbnM/OiBDb25uZWN0aW9uU2VydmljZU9wdGlvbnMpOiBPYnNlcnZhYmxlPENvbm5lY3Rpb25TdGF0ZT4ge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNlcnZpY2VPcHRpb25zID0geyAuLi50aGlzLnNlcnZpY2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgfVxuICAgIGlmKHRoaXMuc2VydmljZU9wdGlvbnMuZW5hYmxlSGVhcnRiZWF0KSB7XG4gICAgICB0aGlzLmNoZWNrSW50ZXJuZXRTdGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGF0ZUNoYW5nZWQkO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIl19