import { __assign, __awaiter, __generator, __decorate, __param } from 'tslib';
import { InjectionToken, Inject, Optional, ɵɵdefineInjectable, ɵɵinject, Injectable, NgModule } from '@angular/core';
import { Subscription, BehaviorSubject, fromEvent, interval } from 'rxjs';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { switchMap } from 'rxjs/operators';

/**
 * InjectionToken for specifing ConnectionService options.
 */
var ConnectionServiceOptionsToken = new InjectionToken('ConnectionServiceOptionsToken');
var DEFAULT_CONNECTION_STATE = {
    hasInternetAccess: true,
    hasNetworkConnection: window.navigator.onLine
};
var DEFAULT_HEART_BEAT_INTERVAL = 1000;
// export const DEFAULT_HEART_BEAT_URL = 'https://jsonplaceholder.typicode.com';
var DEFAULT_HEART_BEAT_URL = 'http://localhost:3000';
var DEFAULT_HEART_BEAT_RETRY_INTERVAL = 1000;
var HTTP_REQUEST_METHODS;
(function (HTTP_REQUEST_METHODS) {
    HTTP_REQUEST_METHODS["HEAD"] = "head";
    HTTP_REQUEST_METHODS["GET"] = "get";
    HTTP_REQUEST_METHODS["POST"] = "post";
    HTTP_REQUEST_METHODS["PUT"] = "put";
    HTTP_REQUEST_METHODS["OPTIONS"] = "options";
})(HTTP_REQUEST_METHODS || (HTTP_REQUEST_METHODS = {}));
var DEFAULT_OPTIONS = {
    enableHeartbeat: false,
    heartbeatUrl: DEFAULT_HEART_BEAT_URL,
    heartbeatInterval: DEFAULT_HEART_BEAT_INTERVAL,
    heartbeatRetryInterval: 1000,
    requestMethod: HTTP_REQUEST_METHODS.HEAD
};
var ConnectionService = /** @class */ (function () {
    function ConnectionService(http, options) {
        this.http = http;
        this.currentState = DEFAULT_CONNECTION_STATE;
        this.serviceOptions = DEFAULT_OPTIONS;
        this.subscription = new Subscription();
        this.httpSubscription = new Subscription();
        this.stateChanged$ = new BehaviorSubject(DEFAULT_CONNECTION_STATE);
        // TODO: Token useValue in providers not working.
        this.serviceOptions = __assign(__assign({}, DEFAULT_OPTIONS), options);
        this.checkNetworkState();
        if (this.serviceOptions.enableHeartbeat) {
            this.checkInternetState();
        }
    }
    ConnectionService.prototype.checkNetworkState = function () {
        var _this = this;
        this.subscription.add(fromEvent(window, 'online').subscribe(function () {
            _this.currentState.hasNetworkConnection = true;
            _this.checkInternetState();
            _this.publishState();
        }));
        this.subscription.add(fromEvent(window, 'offline').subscribe(function () {
            _this.currentState.hasNetworkConnection = false;
            _this.checkInternetState();
            _this.publishState();
        }));
    };
    ConnectionService.prototype.checkInternetState = function () {
        var _this = this;
        if (this.serviceOptions.enableHeartbeat) {
            this.subscription = interval(3000).pipe(switchMap(function () { return __awaiter(_this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.http[this.serviceOptions.requestMethod || HTTP_REQUEST_METHODS.HEAD](this.serviceOptions.heartbeatUrl || DEFAULT_HEART_BEAT_URL, { responseType: 'text' }).subscribe({
                            next: function (data) {
                                _this.currentState.hasInternetAccess = true;
                                _this.publishState();
                            },
                            error: function (err) {
                                _this.currentState.hasInternetAccess = false;
                                _this.publishState();
                                throw err;
                            },
                        })];
                });
            }); })).subscribe(function (res) {
            });
            // this.httpSubscription = timer(0, this.serviceOptions.heartbeatInterval || DEFAULT_HEART_BEAT_INTERVAL)
            //   .pipe(
            //     switchMap(async () => this.http[this.serviceOptions.requestMethod || HTTP_REQUEST_METHODS.HEAD](this.serviceOptions.heartbeatUrl || DEFAULT_HEART_BEAT_URL,
            //       { responseType: 'text' })),
            //     retryWhen(errors =>
            //       errors.pipe(
            //         // log error message
            //         tap(val => {
            //           this.currentState.hasInternetAccess = false;
            //           this.publishState();
            //           throw errors;
            //         }),
            //         // restart after 5 seconds
            //         delay(this.serviceOptions.heartbeatRetryInterval || DEFAULT_HEART_BEAT_RETRY_INTERVAL)
            //       )
            //     )
            //   )
            //   .subscribe(result => {
            //     this.currentState.hasInternetAccess = true;
            //     this.publishState();
            //   });
        }
        else {
            this.currentState.hasInternetAccess = false;
            this.publishState();
        }
    };
    ConnectionService.prototype.publishState = function () {
        this.stateChanged$.next(this.currentState);
    };
    /**
   * Monitor Network & Internet connection status by subscribing to this observer. If you set "reportCurrentState" to "false" then
   * function will not report current status of the connections when initially subscribed.
   * @param reportCurrentState Report current state when initial subscription. Default is "true"
   */
    ConnectionService.prototype.monitor = function (options) {
        if (options) {
            this.serviceOptions = __assign(__assign({}, this.serviceOptions), options);
        }
        if (this.serviceOptions.enableHeartbeat) {
            this.checkInternetState();
        }
        return this.stateChanged$;
    };
    ConnectionService.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
    };
    ConnectionService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: undefined, decorators: [{ type: Inject, args: [ConnectionServiceOptionsToken,] }, { type: Optional }] }
    ]; };
    ConnectionService.ɵprov = ɵɵdefineInjectable({ factory: function ConnectionService_Factory() { return new ConnectionService(ɵɵinject(HttpClient), ɵɵinject(ConnectionServiceOptionsToken, 8)); }, token: ConnectionService, providedIn: "root" });
    ConnectionService = __decorate([
        Injectable({
            providedIn: 'root'
        }),
        __param(1, Inject(ConnectionServiceOptionsToken)), __param(1, Optional())
    ], ConnectionService);
    return ConnectionService;
}());

var ConnectionServiceModule = /** @class */ (function () {
    function ConnectionServiceModule() {
    }
    ConnectionServiceModule = __decorate([
        NgModule({
            imports: [HttpClientModule],
            providers: [ConnectionService]
        })
    ], ConnectionServiceModule);
    return ConnectionServiceModule;
}());

/*
 * Public API Surface of ng-connection-service
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ConnectionService, ConnectionServiceModule, ConnectionServiceOptionsToken, DEFAULT_CONNECTION_STATE, DEFAULT_HEART_BEAT_INTERVAL, DEFAULT_HEART_BEAT_RETRY_INTERVAL, DEFAULT_HEART_BEAT_URL, DEFAULT_OPTIONS, HTTP_REQUEST_METHODS };
//# sourceMappingURL=ng-connection-service.js.map
